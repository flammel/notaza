
type BacklinkBlock = BlockForView;
interface BacklinkPage {
    title: string;
    id: string;
    backlinks: BacklinkBlock[];
}

// export class PageController {
//     public readonly view: PageView;
//     private blocks: BlockView[] = [];

//     constructor(private readonly store: Store) {
//         this.view = new PageView();

//         this.page$
//             .pipe(
//                 map((page) => page?.title || ''),
//                 distinctUntilChanged(),
//             )
//             .subscribe((title) => this.view.setTitle(title));

//         this.blocks$.subscribe((blocks) => {
//             this.blockControllers = _.zip(blocks, this.blockControllers).reduce(
//                 (
//                     acc: BlockController[],
//                     cur: [BlockForView | undefined, BlockController | undefined],
//                 ): BlockController[] => {
//                     const [block, controller] = cur;
//                     if (block !== undefined && controller !== undefined) {
//                         controller.setBlock(block);
//                         return [...acc, controller];
//                     } else if (block === undefined && controller !== undefined) {
//                         controller.view.$element.remove();
//                         return acc;
//                     } else if (block !== undefined && controller === undefined) {
//                         const newController = new BlockController(this, block);
//                         this.view.appendBlock(newController.view.$element);
//                         return [...acc, newController];
//                     }
//                     return acc;
//                 },
//                 [],
//             );
//         });
//     }

//     private get page$(): Observable<Page | undefined> {
//         return this.store.state$.pipe(map((state) => state.pages.find((page) => page.id === state.activePageId)));
//     }

//     private get blocks$(): Observable<BlockForView[]> {
//         const blocks$ = this.page$.pipe(map((page) => (page === undefined ? [] : page.children)));
//         const editing$ = this.store.state$.pipe(map((state) => state.editing?.blockPath));
//         return combineLatest(blocks$, editing$, (blocks, editing) =>
//             blocks.map((block, index) => this.blockForView(block, editing, [index])),
//         ).pipe(distinctUntilChanged(_.isEqual));
//     }

//     // private renderBacklinks(): HTMLUListElement {
//     //     const $backlinks = document.createElement('ul');
//     //     $backlinks.classList.add('backlinks');

//     //     this.controller.backlinks$.subscribe((backlinkPages) => {
//     //         $backlinks.innerHTML = '';
//     //         for (const backlinkPage of backlinkPages) {
//     //             const $pageLink = document.createElement('a');
//     //             $pageLink.classList.add('internal');
//     //             $pageLink.setAttribute('href', './' + backlinkPage.id);
//     //             $pageLink.innerText = backlinkPage.title;

//     //             const $pageBacklinks = document.createElement('ul');
//     //             for (const backlinkBlock of backlinkPage.backlinks) {
//     //                 const $backlink = document.createElement('li');
//     //                 $backlink.innerHTML = backlinkBlock.renderedContent;
//     //                 $pageBacklinks.appendChild($backlink);
//     //             }

//     //             const $li = document.createElement('li');
//     //             $li.appendChild($pageLink);
//     //             $li.appendChild($pageBacklinks);
//     //             $backlinks.appendChild($li);
//     //         }
//     //     });

//     //     return $backlinks;
//     // }

//     public get backlinks$(): Observable<BacklinkPage[]> {
//         return combineLatest(this.page$, this.store.state$.pipe(map((state) => state.pages)), (activePage, pages) => {
//             if (activePage === undefined) {
//                 return [];
//             }
//             const pagesWithLinks = [];
//             for (const page of pages) {
//                 if (page.id !== activePage.id) {
//                     const backlinks = [];
//                     for (const child of page.children) {
//                         backlinks.push(
//                             ...this.getBacklinks(child, activePage.id).map((block) => ({
//                                 rawContent: block.content,
//                                 renderedContent: this.store.renderer.render(block.content),
//                                 editing: false,
//                                 children: [],
//                                 path: [],
//                             })),
//                         );
//                     }
//                     if (backlinks.length > 0) {
//                         pagesWithLinks.push({
//                             title: page.title,
//                             id: page.id,
//                             backlinks,
//                         });
//                     }
//                 }
//             }
//             return pagesWithLinks;
//         });
//     }

//     public onBlockClick(blockPath: BlockPath): void {
//         this.store.dispatch(actions.onBlockClick(blockPath));
//     }

//     public onEditorInput(blockPath: BlockPath, content: string): void {
//         this.store.dispatch(actions.onEditorInput(blockPath, content));
//     }

//     public onEditorKeyDown(blockPath: BlockPath, event: KeyboardEvent, $textarea: HTMLTextAreaElement): void {

//     }

//     public makeBlockController(block: BlockForView): BlockController {
//         return new BlockController(this, block);
//     }

//     private getBacklinks(block: Block, target: PageId): Block[] {
//         const result = _.flatten(block.children.map((child) => this.getBacklinks(child, target)));
//         if (block.content.includes('](./' + target + '.md)') || block.content.includes('#' + target)) {
//             result.push(block);
//         }
//         return result;
//     }

//     private blockForView(block: Block, editing: BlockPath | undefined, path: BlockPath): BlockForView {
//         return {
//             rawContent: block.content,
//             renderedContent: this.store.renderer.render(block.content),
//             editing: _.isEqual(editing, path),
//             children: block.children.map((child, index) => this.blockForView(child, editing, [...path, index])),
//             path,
//         };
//     }
// }