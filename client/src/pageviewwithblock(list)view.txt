import { Observable, Subject, BehaviorSubject, combineLatest } from 'rxjs';
import * as _ from 'lodash';
import { Block, BlockPath, PageId, Page } from '../types';
import { map, distinctUntilChanged, pluck } from 'rxjs/operators';
import { Store } from '../store';
import * as actions from '../actions';
import { WrappedElement, bindInnerText } from '../html';

interface BlockForView {
    rawContent: string;
    renderedContent: string;
    editing: boolean;
    children: BlockForView[];
    path: BlockPath;
}

// type BlockWithoutChildren = Omit<BlockForView, 'children'>;

function resize($textarea: HTMLTextAreaElement): void {
    $textarea.setAttribute('rows', '1');
    $textarea.style.height = 'auto';
    $textarea.style.height = $textarea.scrollHeight + 'px';
}

// class BlockContentView extends HTMLDivElement {
//     private path: BlockPath | undefined;
//     private $textarea: HTMLTextAreaElement | undefined;

//     constructor(store: Store, block$: Observable<BlockWithoutChildren>) {
//         super();
//         this.classList.add('block__content');
//         this.addEventListener('click', (event) => {
//             if (this.path !== undefined) {
//                 if (event.target instanceof HTMLInputElement && event.target.type === 'checkbox') {
//                     store.dispatch(actions.onCheckboxClick(this.path));
//                 } else {
//                     store.dispatch(actions.onBlockClick(this.path));
//                 }
//             }
//         });
//         block$.pipe(distinctUntilChanged(_.isEqual)).subscribe((block) => {
//             this.path = block.path;
//             if (block.editing) {
//                 if (!this.$textarea) {
//                     const $textarea = document.createElement('textarea');
//                     $textarea.classList.add('editor');
//                     $textarea.innerHTML = block.rawContent;
//                     $textarea.addEventListener('input', () => {
//                         store.dispatch(actions.onEditorInput(block.path, $textarea.value));
//                         resize($textarea);
//                     });
//                     $textarea.addEventListener('keydown', (event) =>
//                         handleEditorKeyDown(event, $textarea, store, block),
//                     );
//                     this.innerHTML = '';
//                     this.appendChild($textarea);
//                     $textarea.focus();
//                     $textarea.setSelectionRange($textarea.value.length, $textarea.value.length);
//                     resize($textarea);
//                     this.$textarea = $textarea;
//                 }
//             } else {
//                 this.innerHTML = block.renderedContent;
//                 this.$textarea = undefined;
//             }
//         });
//     }

//     public connectedCallback(): void {
//         if (this.$textarea) {
//             resize(this.$textarea);
//             this.$textarea.focus();
//             this.$textarea.setSelectionRange(this.$textarea.value.length, this.$textarea.value.length);
//         }
//     }
// }
// customElements.define('n-block-content', BlockContentView, { extends: 'div' });

// class BlockView extends HTMLLIElement {
//     constructor(store: Store, block$: Observable<BlockForView>) {
//         super();
//         this.classList.add('block');
//         const onlyChildren$ = block$.pipe(pluck('children'), distinctUntilChanged(_.isEqual));
//         const withoutChildren$ = block$.pipe(
//             map((block) => _.omit(block, 'children')),
//             distinctUntilChanged(_.isEqual),
//         );
//         withoutChildren$.subscribe(({ editing }) =>
//             editing ? this.classList.add('block--editing') : this.classList.remove('block--editing'),
//         );
//         this.appendChild(new BlockContentView(store, withoutChildren$));
//         this.appendChild(new BlockList(store, onlyChildren$));
//     }
// }
// customElements.define('n-block', BlockView, { extends: 'li' });

// class BlockList extends HTMLUListElement {
//     constructor(store: Store, blocks$: Observable<BlockForView[]>) {
//         super();

//         const observables: Subject<BlockForView>[] = [];
//         blocks$.subscribe((blocks) => {
//             for (const [block, observable] of _.zip(blocks, observables)) {
//                 if (block) {
//                     if (observable) {
//                         observable.next(block);
//                     } else {
//                         const newObservable = new BehaviorSubject<BlockForView>(block);
//                         observables.push(newObservable);
//                         const newView = new BlockView(store, newObservable);
//                         this.appendChild(newView);
//                         newObservable.subscribe({ complete: () => this.removeChild(newView) });
//                     }
//                 } else {
//                     if (observable) {
//                         observable.complete();
//                         observables.pop();
//                     }
//                 }
//             }
//         });
//     }
// }
// customElements.define('n-block-list', BlockList, { extends: 'ul' });


type BacklinkBlock = BlockForView;

interface BacklinkPage {
    title: string;
    id: string;
    backlinks: BacklinkBlock[];
}

export class PageController {
    constructor(private readonly store: Store) {}

    public get title$(): Observable<string> {
        return this.page$.pipe(
            map((page) => page?.title || ''),
            distinctUntilChanged(),
        );
    }

    public get blocks$(): Observable<BlockForView[]> {
        const blocks$ = this.page$.pipe(map((page) => (page === undefined ? [] : page.children)));
        const editing$ = this.store.state$.pipe(map((state) => state.editing?.blockPath));
        return combineLatest(blocks$, editing$, (blocks, editing) =>
            blocks.map((block, index) => this.blockForView(block, editing, [index])),
        ).pipe(distinctUntilChanged(_.isEqual));
    }

    public get backlinks$(): Observable<BacklinkPage[]> {
        return combineLatest(this.page$, this.store.state$.pipe(map((state) => state.pages)), (activePage, pages) => {
            if (activePage === undefined) {
                return [];
            }
            const pagesWithLinks = [];
            for (const page of pages) {
                if (page.id !== activePage.id) {
                    const backlinks = [];
                    for (const child of page.children) {
                        backlinks.push(
                            ...this.getBacklinks(child, activePage.id).map((block) => ({
                                rawContent: block.content,
                                renderedContent: this.store.renderer.render(block.content),
                                editing: false,
                                children: [],
                                path: [],
                            })),
                        );
                    }
                    if (backlinks.length > 0) {
                        pagesWithLinks.push({
                            title: page.title,
                            id: page.id,
                            backlinks,
                        });
                    }
                }
            }
            return pagesWithLinks;
        });
    }

    public onBlockClick(blockPath: BlockPath): void {
        this.store.dispatch(actions.onBlockClick(blockPath));
    }

    public onEditorInput(blockPath: BlockPath, content: string): void {
        this.store.dispatch(actions.onEditorInput(blockPath, content));
    }

    public onEditorKeyDown(blockPath: BlockPath, event: KeyboardEvent, $textarea: HTMLTextAreaElement): void {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            const contentBefore = $textarea.value.substring(0, $textarea.selectionStart);
            const contentAfter = $textarea.value.substring($textarea.selectionEnd);
            this.store.dispatch(actions.splitBlock(blockPath, contentBefore, contentAfter));
        } else if (event.key === 'Tab') {
            event.preventDefault();
            if (event.shiftKey) {
                this.store.dispatch(actions.decreaseLevel(blockPath, $textarea.value));
            } else {
                this.store.dispatch(actions.increaseLevel(blockPath, $textarea.value));
            }
        } else if (event.key === 'Delete' && $textarea.value.length === 0) {
            event.preventDefault();
            this.store.dispatch(actions.deleteBlock(blockPath));
        } else if (event.key === 'Backspace' && $textarea.value.length === 0) {
            event.preventDefault();
            this.store.dispatch(actions.deleteBlock(blockPath));
        } else if (event.key === 'ArrowUp' && event.shiftKey) {
            event.preventDefault();
            this.store.dispatch(actions.startEditingPrevious(blockPath, $textarea.value));
        } else if (event.key === 'ArrowDown' && event.shiftKey) {
            event.preventDefault();
            this.store.dispatch(actions.startEditingNext(blockPath, $textarea.value));
        } else if (event.key === 's' && event.ctrlKey) {
            event.preventDefault();
            this.store.dispatch(actions.stopEditing(blockPath, $textarea.value));
        } else if (event.key === 'Escape') {
            event.preventDefault();
            this.store.dispatch(actions.stopEditing(blockPath, $textarea.value));
        }
    }

    private getBacklinks(block: Block, target: PageId): Block[] {
        const result = _.flatten(block.children.map((child) => this.getBacklinks(child, target)));
        if (block.content.includes('](./' + target + '.md)') || block.content.includes('#' + target)) {
            result.push(block);
        }
        return result;
    }

    private get page$(): Observable<Page | undefined> {
        return this.store.state$.pipe(map((state) => state.pages.find((page) => page.id === state.activePageId)));
    }

    private blockForView(block: Block, editing: BlockPath | undefined, path: BlockPath): BlockForView {
        return {
            rawContent: block.content,
            renderedContent: this.store.renderer.render(block.content),
            editing: _.isEqual(editing, path),
            children: block.children.map((child, index) => this.blockForView(child, editing, [...path, index])),
            path,
        };
    }
}

class BlockView implements WrappedElement {
    public readonly $element: HTMLElement;
    constructor() {
        this.$element = document.createElement('li');
    }

    private getBlockElement(blockPath: BlockPath): BlockElement {
        const key = blockPath.join('');
        const $existing = this.blockMap.get(key);
        if ($existing === undefined) {
            const $element = document.createElement('li');
            $element.classList.add('block');

            const $self = document.createElement('div');
            $self.classList.add('block__self');

            const $children = document.createElement('ul');
            $children.classList.add('blocks', 'block__children');

            $element.appendChild($self);
            $element.appendChild($children);

            const blockElement = {
                $element,
                $self,
                $children,
            };

            this.blockMap.set(key, blockElement);
            return blockElement;
        } else {
            return $existing;
        }
    }

    private renderBlock(block: BlockForView): HTMLElement {
        const blockElement = this.getBlockElement(block.path);
        for (const child of block.children) {
            blockElement.$children.appendChild(this.renderBlock(child));
        }
        blockElement.$self.appendChild(block.editing ? this.renderEditor(block) : this.renderContent(block));

        return blockElement.$element;
    }

    private renderEditor(block: BlockForView): HTMLElement {
        const $textarea = document.createElement('textarea');
        $textarea.classList.add('editor');
        $textarea.innerHTML = block.rawContent;
        $textarea.addEventListener('input', () => this.controller.onEditorInput(block.path, $textarea.value));
        $textarea.addEventListener('keydown', (event) => this.controller.onEditorKeyDown(block.path, event, $textarea));
        return $textarea;
    }

    private renderContent(block: BlockForView): HTMLElement {
        const $content = document.createElement('div');
        $content.classList.add('block__content');
        $content.innerHTML = block.renderedContent;
        $content.addEventListener('click', () => this.controller.onBlockClick(block.path));
        return $content;
    }
}

class BlockListController {
    constructor(private readonly pageController: PageController, private readonly path: BlockPath) {}

    public get blocks$(): Observable<BlockForView[]> {
        this.pageController.
    }
}

class BlockListView implements WrappedElement {
    public readonly $element: HTMLElement;
    private readonly blockViews = new Map<string, BlockView>();

    constructor(controller: BlockListController) {
        this.$element = document.createElement('ul');
        this.$element.classList.add('blocks');

        controller.blocks$.subscribe((blocks) => {
            $blocks.innerHTML = '';
            for (const block of blocks) {
                $blocks.appendChild(this.renderBlock(block));
            }
        });
    }
}

export class PageView implements WrappedElement {
    public readonly $element: HTMLElement;

    constructor(private readonly controller: PageController) {
        const $title = document.createElement('h1');
        bindInnerText($title, controller.title$);

        const $backlinksHeadline = document.createElement('h2');
        $backlinksHeadline.innerText = 'Backlinks';

        const blockListView = new BlockListView(new BlockListController(controller, []));

        this.$element = document.createElement('div');
        this.$element.classList.add('page');
        this.$element.appendChild($title);
        this.$element.appendChild(blockListView.$element);
        this.$element.appendChild($backlinksHeadline);
        this.$element.appendChild(this.renderBacklinks());

        const mutationObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                console.log(mutation);
            }
        });
        mutationObserver.observe(this.$element, { childList: true, subtree: true });
    }

    private renderBacklinks(): HTMLUListElement {
        const $backlinks = document.createElement('ul');
        $backlinks.classList.add('backlinks');

        this.controller.backlinks$.subscribe((backlinkPages) => {
            $backlinks.innerHTML = '';
            for (const backlinkPage of backlinkPages) {
                const $pageLink = document.createElement('a');
                $pageLink.classList.add('internal');
                $pageLink.setAttribute('href', './' + backlinkPage.id);
                $pageLink.innerText = backlinkPage.title;

                const $pageBacklinks = document.createElement('ul');
                for (const backlinkBlock of backlinkPage.backlinks) {
                    const $backlink = document.createElement('li');
                    $backlink.innerHTML = backlinkBlock.renderedContent;
                    $pageBacklinks.appendChild($backlink);
                }

                const $li = document.createElement('li');
                $li.appendChild($pageLink);
                $li.appendChild($pageBacklinks);
                $backlinks.appendChild($li);
            }
        });

        return $backlinks;
    }
}
